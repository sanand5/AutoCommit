
Esta es la salida de mi `git diff HEAD`. Quiero que generes un único commit que englobe todos los cambios en castellano, utilizando títulos y mensajes apropiados para cada diff. 
- La salida se debe de poder ejectar en la consola
- No debes incluir ningun texto adicional
- La salida debe seguir estrictamente este formato: git commit -m "título descriptivo del commit" -m "mensaje del commit"
- El título puede ser en inglés pero la descripción debe ser en castellano.
Solo debes generar una unica salida

Ruta: a/README.md
Cambios:
index 53925aa..fb134fc 100644
--- a/README.md
+++ b/README.md
@@ -1 +1,64 @@
-# AutoCommit
\ No newline at end of file
+# AutoCommit - Generación Automática de Commits
+## Descripción
+AutoCommit es una herramienta que simplifica la creación de commits en Git utilizando la API de Google Generative AI. Facilita la generación automática de mensajes de commit basados en los cambios detectados en el repositorio y permite filtrar archivos de forma manual o automatizada usando inteligencia artificial.
+
+## Funcionalidades
+- Generación automática de mensajes de commit usando un modelo de IA.
+- Filtrado de archivos en el git diff para excluir los irrelevantes.
+- Integración con Git, incluyendo adición (git add), creación de diffs (git diff) y commits (git commit).
+- Interfaz de línea de comandos para una fácil interacción.
+- Compatibilidad con diferentes tipos de archivos para análisis de diffs.
+
+## Instalación
+### Clonar el repositorio:
+```bash
+git clone <URL_DEL_REPOSITORIO>
+cd AutoCommit
+```
+### Instalar dependencias:
+```bash
+python3 -m venv venv_autocommit
+source venv_autocommit/bin/activate
+pip install -r requirements.txt
+```
+### Configurar la API Key de Google Generative AI:
+Asegúrate de tener configurada la variable de entorno `API_KEY` con tu clave de API:
+```bash
+export API_KEY="tu_api_key"
+```
+
+## Uso
+### Comando principal
+El script de shell `autocommit.sh` permite ejecutar el proceso completo de generación de commits:
+```bash
+bash autocommit.sh <ruta_del_repositorio>
+```
+
+## Menú de opciones
+Durante la ejecución, se te presentará un menú con las siguientes opciones:
+
+1. **Eliminar ficheros manualmente**: Permite seleccionar archivos del git diff para eliminar manualmente.
+2. **Eliminar ficheros con IA**: Utiliza IA para sugerir archivos a eliminar del git diff.
+3. **Generar Commit**: Genera un mensaje de commit utilizando IA.
+4. **Git Commit y Salir**: Crea el commit con el mensaje generado y termina el proceso.
+
+## Archivos del proyecto
+- `gestor.py`: Contiene funciones para gestionar los diffs y procesar archivos.
+- `git.py`: Funciones para interactuar con Git (`git add`, `git commit`, `git diff`).
+- `menu.py`: Implementa el menú interactivo para la selección de opciones.
+- `config.py`: Configuración global del proyecto, incluyendo extensiones permitidas y prompts para IA.
+- `init.py`: Punto de entrada del programa.
+- `autocommit.py`: Función principal para la ejecución del autocommit.
+- `autocommit.sh`: Script de shell para activar el entorno virtual y ejecutar el programa.
+
+## Requisitos
+- Python 3.8 o superior.
+- Acceso a la API de Google Generative AI.
+- Git instalado y configurado.
+
+## Contribuir
+1. Haz un fork del proyecto.
+2. Crea una nueva rama (`git checkout -b feature/nueva-funcionalidad`).
+3. Realiza tus cambios y haz commit (`git commit -m "Agregar nueva funcionalidad"`).
+4. Envía tus cambios (`git push origin feature/nueva-funcionalidad`).
+5. Crea un Pull Request.


Ruta: a/TODO.md
Cambios:
index 8672f59..bdf384f 100644
--- a/TODO.md
+++ b/TODO.md
@@ -1,4 +1,5 @@
 - Limpiar Codigo
 - Gestionar Errores
-- Actualizar requirement
-- Actualizar REademi, añadir en reademe lo de para el comando
\ No newline at end of file
+
+## Nuevas Funcionalidades
+introducir un fichero .autocommitignore en el repositorio donde introducir que ficheros o carpetas no se deven introducir en el repositorio.
\ No newline at end of file


Ruta: a/comando.txt
Cambios:
similarity index 100%
rename from comando.txt
rename to alias.txt


Ruta: a/autocommit.py
Cambios:
index 446e602..7c43fe5 100644
--- a/autocommit.py
+++ b/autocommit.py
@@ -1,11 +1,14 @@
+import os
+import sys
+
 import config
 import gestor as g
 import menu as m
 import git as git
-import sys
 
 def autocommit():
-    config.REPOSITORIO = sys.argv[1]
+    #config.REPOSITORIO = os.path.abspath(sys.argv[1])
+    config.REPOSITORIO = os.path.abspath(".")
     g.print_info()
     g.diffhead()
     config.cambios = g.leer_diff(config.DIFF_INPUT_FILE, config.EXTENSIONES_PERMITIDAS)


Ruta: a/autocommit.sh
Cambios:
index a21f25a..bd3c359 100755
--- a/autocommit.sh
+++ b/autocommit.sh
@@ -2,10 +2,11 @@
 
 ruta=$1
 # Activar el entorno virtual
-source ./venv_autocommit/bin/activate
+dir="$(dirname "$(realpath "$0")")"
+source "$dir/venv_autocommit/bin/activate"
 
 # Ejecutar el script de Python
-python3 ./init.py $ruta
+python3 "$dir/init.py" $ruta
 
 # Desactivar el entorno virtual (opcional)
 deactivate


Ruta: a/file_utils.py
Cambios:
new file mode 100644
index 0000000..5a4a1a8
--- /dev/null
+++ b/file_utils.py
@@ -0,0 +1,45 @@
+import os
+import re
+import config
+
+def crear_directorio_output(directorio_script):
+    """Crea el directorio output si no existe."""
+    output_dir = os.path.join(directorio_script, "output")
+    os.makedirs(output_dir, exist_ok=True)
+    return output_dir
+
+def anadir_salto_linea(diff_file_path):
+    """Añade un salto de línea al archivo diff.txt."""
+    with open(diff_file_path, 'a') as diff_file:
+        diff_file.write("\n")
+
+def leer_diff(archivo_diff, extensiones_permitidas):
+    """Lee un archivo diff y filtra por extensiones permitidas."""
+    cambios = {}
+    ruta_actual = None
+    contenido_diff = []
+
+    with open(archivo_diff, 'r') as f:
+        for linea in f:
+            if linea.startswith('diff --git'):
+                if ruta_actual and contenido_diff:
+                    if any(ruta_actual.endswith(ext) for ext in extensiones_permitidas):
+                        cambios[ruta_actual] = ''.join(contenido_diff)
+
+                contenido_diff = []  # Reinicia el contenido del diff
+                match = re.match(r'diff --git (a/.+) (b/.+)', linea)
+                if match:
+                    ruta_actual = match.group(1)  # La ruta del archivo a
+            elif ruta_actual:
+                contenido_diff.append(linea)
+
+        if ruta_actual and contenido_diff:
+            if any(ruta_actual.endswith(ext) for ext in extensiones_permitidas):
+                cambios[ruta_actual] = ''.join(contenido_diff)
+
+    return cambios
+
+def guardar(cambios_str):
+    """Guarda los cambios formateados en un archivo."""
+    with open(config.DIFF_FORMATED_FILE, "w") as f:
+        f.write(cambios_str)


Ruta: a/gestor.py
Cambios:
index 613fb17..07cbb0a 100644
--- a/gestor.py
+++ b/gestor.py
@@ -1,18 +1,21 @@
 import config
 import git
-import os
-import re
+from file_utils import crear_directorio_output, anadir_salto_linea, leer_diff, guardar
 import google.api_core.exceptions as api_errors
+import os
+
 
 def print_info():
+    """Muestra información relevante de la configuración."""
     print(f"Directorio actual: {config.DIRECTORIO}")
     print(f"Repositorio: {config.REPOSITORIO}")
-    print(f"Directorio de salida de el programa: {config.OUTPUT_DIR}")
+    print(f"Directorio de salida del programa: {config.OUTPUT_DIR}")
     print(f"Modelo: {config.MODEL.model_name}")
-    print(f"Limite de intentos: {config.LIMITE_INTENTOS}")
+    print(f"Límite de intentos: {config.LIMITE_INTENTOS}")
     print()
 
 def diffhead():
+    """Genera un diff del repositorio y lo guarda en un archivo."""
     git.git_add(".")
     output_dir = crear_directorio_output(config.DIRECTORIO)
     diff_file_path = os.path.join(output_dir, "diff.txt")
@@ -20,33 +23,21 @@ def diffhead():
     git.git_diff_head(diff_file_path)
     print(f"Diff generado en: {diff_file_path}")
 
-def crear_directorio_output(directorio_script):
-    """Crea el directorio output si no existe."""
-    output_dir = os.path.join(directorio_script, "output")
-    os.makedirs(output_dir, exist_ok=True)
-    return output_dir
-
-def anadir_salto_linea(diff_file_path):
-    """Añade un salto de línea al archivo diff.txt."""
-    with open(diff_file_path, 'a') as diff_file:
-        diff_file.write("\n")
-
 def anadir_prompt():
+    """Genera el mensaje con los cambios a enviar a la IA."""
     cambios_str = "\n\n".join([f"Ruta: {ruta}\nCambios:\n{diff}" for ruta, diff in config.cambios.items()])
-    difftoAI = config.PROMPT + "\n" + cambios_str
-    return difftoAI
-
-def guardar(cambios_str):
-    with open(config.DIFF_FORMATED_FILE, "w") as f:
-            f.write(cambios_str)
+    return config.PROMPT + "\n" + cambios_str
 
 def obtener_rutas():
+    """Obtiene las rutas de los cambios registrados."""
     return list(config.cambios.keys())
 
 def obtener_indices_a_eliminar():
+    """Solicita los índices de archivos a eliminar."""
     return input("Introduce los ficheros a eliminar (separados por espacio o un rango como 7-10): ")
 
 def procesar_indices(indices_a_eliminar):
+    """Procesa los índices ingresados para determinar los archivos a eliminar."""
     indices = set()
     for parte in indices_a_eliminar.split():
         if '-' in parte:
@@ -60,52 +51,25 @@ def procesar_indices(indices_a_eliminar):
     return indices
 
 def eliminar_archivos(indices):
+    """Elimina los archivos según los índices proporcionados."""
     rutas = obtener_rutas()
     for idx in sorted(indices, reverse=True):
         if 0 <= idx < len(rutas):
             config.cambios.pop(rutas[idx], None)
 
-def leer_diff(archivo_diff, extensiones_permitidas):
-    cambios = {}
-    ruta_actual = None
-    contenido_diff = []
-
-    with open(archivo_diff, 'r') as f:
-        for linea in f:
-            # Verifica si la línea indica el inicio de un nuevo archivo
-            if linea.startswith('diff --git'):
-                if ruta_actual and contenido_diff:
-                    # Filtrar cambios según la extensión del archivo
-                    if any(ruta_actual.endswith(ext) for ext in extensiones_permitidas):
-                        cambios[ruta_actual] = ''.join(contenido_diff)
-
-                contenido_diff = []  # Reinicia el contenido del diff
-                # Usamos expresión regular para obtener las rutas de los archivos (con espacios)
-                match = re.match(r'diff --git (a/.+) (b/.+)', linea)
-                if match:
-                    ruta_actual = match.group(1)  # La ruta del archivo a
-            elif ruta_actual:  # Si hay un archivo actual, agrega su contenido
-                contenido_diff.append(linea)
-
-        # Guarda el último archivo leído
-        if ruta_actual and contenido_diff:
-            if any(ruta_actual.endswith(ext) for ext in extensiones_permitidas):
-                cambios[ruta_actual] = ''.join(contenido_diff)
-
-    return cambios
-
-
 def __gemini(msg):
-    response = config.MODEL.generate_content(msg)
-    return response
+    """Genera el contenido usando la IA configurada."""
+    return config.MODEL.generate_content(msg)
 
 def obtener_primera_linea_commit(texto):
+    """Obtiene la primera línea de commit de un mensaje."""
     for linea in texto.splitlines():
         if linea.startswith("git commit"):
             return linea
     return None
 
 def getcommit():
+    """Obtiene un mensaje de commit generado por la IA."""
     msg = anadir_prompt()
     cont = 0
     continuar = True
@@ -113,7 +77,7 @@ def getcommit():
     while continuar:
         config.commit = obtener_primera_linea_commit(__gemini(msg).text)
         
-        if config.commit != None:
+        if config.commit:
             continuar = False
         else:
             cont += 1
@@ -123,31 +87,30 @@ def getcommit():
     print(config.commit)
     return True
 
-
 def hacer_commit():
-    if config.commit != "":
-        if getcommit(): git.git_commit(config.commit)
-        else: 
+    """Realiza el commit si el mensaje es válido."""
+    if config.commit:
+        if getcommit():
+            git.git_commit(config.commit)
+        else:
             print("No se ha podido hacer el commit")
             return False
-    else: 
+    else:
         print("No se ha podido hacer el commit")
         return False
     return True
 
 def lista_ficheros():
-    rutas = obtener_rutas()  # Suponiendo que esta función devuelve las rutas
+    """Genera una lista de archivos con sus índices."""
+    rutas = obtener_rutas()
     lista_ficheros = "Ficheros:\n"
     for idx, ruta in enumerate(rutas, start=1):
         lista_ficheros += f"\t{idx}. {ruta}\n"
     return lista_ficheros
 
 def getFicherosAI():
+    """Obtiene los ficheros a eliminar mediante la IA."""
     msg = config.PROMPT_FICHEROS + "\n" + lista_ficheros()
     indices_a_eliminar = __gemini(msg).text    
     indices = procesar_indices(indices_a_eliminar)
     eliminar_archivos(indices)
-
-
-
-


Ruta: a/ignore.py
Cambios:
new file mode 100644
index 0000000..1bc5a3c
--- /dev/null
+++ b/ignore.py
@@ -0,0 +1,3 @@
+# Leer ficheros autocommit
+# Sacar todas las rutas absolutas de todo lo que hay que ignorar
+# Eliminar esos ficheros de cambios


Ruta: a/requirements.txt
Cambios:
new file mode 100644
index 0000000..943d6a5
--- /dev/null
+++ b/requirements.txt
@@ -0,0 +1,28 @@
+annotated-types==0.7.0
+cachetools==5.5.0
+certifi==2024.8.30
+charset-normalizer==3.4.0
+google-ai-generativelanguage==0.6.10
+google-api-core==2.23.0
+google-api-python-client==2.153.0
+google-auth==2.36.0
+google-auth-httplib2==0.2.0
+google-generativeai==0.8.3
+googleapis-common-protos==1.66.0
+grpcio==1.67.1
+grpcio-status==1.67.1
+httplib2==0.22.0
+idna==3.10
+proto-plus==1.25.0
+protobuf==5.28.3
+pyasn1==0.6.1
+pyasn1_modules==0.4.1
+pydantic==2.9.2
+pydantic_core==2.23.4
+pyparsing==3.2.0
+requests==2.32.3
+rsa==4.9
+tqdm==4.67.0
+typing_extensions==4.12.2
+uritemplate==4.1.1
+urllib3==2.2.3
